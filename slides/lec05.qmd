---
echo: false
title: COMP2870 Theoretical Foundations of Computer Science II
subtitle: Eigenvalues and complex numbers
author:
  - name: Dr. Thomas Ranner (Tom)
    email: T.Ranner@leeds.ac.uk
    affiliation: School of Computer Science, University of Leeds
code-line-numbers: true
html-math-method: mathjax
include-in-header: ../mathjax.html

execute:
  freeze: auto
  cache: true

format:
  live-revealjs:
    slide-level: 3
    slide-number: true
    preview-links: auto
---
## What is an eigenvector?

```{python}
import re

import matplotlib.colors as mcolors
import numpy as np
from matplotlib import pyplot as plt

plt.style.use("seaborn-v0_8-colorblind")
```

Let $A$ be an $n \times n$ matrix. We are interested in when is the output vector $A \vec{x}$ is *parallel* to
$\vec{x}$?

::: {.notes}
For this problem, we will think of a matrix $A$ acting on functions $\vec{x}$:
\begin{equation*}
\vec{x} \mapsto A \vec{x}.
\end{equation*}

To help with our intuition here, we start with some simple examples:

::: {#exm-unequal-scaling-evalues}
Let $A$ be the $2 \times 2$ matrix that scales any input vector by $a$ in the $x$-direction and by $b$ in the $y$-direction.
We can write this matrix as
\begin{equation*}
A = \begin{pmatrix}
a & 0 \\ 0 & b
\end{pmatrix},
\end{equation*}
since then for a 2-vector $\vec{x} = (x, y)^T$, we have
\begin{equation*}
A \vec{x}
= \begin{pmatrix}
a & 0 \\ 0 & b
\end{pmatrix}
\begin{pmatrix} x \\ y \end{pmatrix}
= \begin{pmatrix} a x + 0 y \\ 0 x + b y \end{pmatrix}
= \begin{pmatrix} a x \\ b y \end{pmatrix}.
\end{equation*}

Then, we infer we have two eigenvalues and two eigenvectors: One eigenvalue is $a$ with eigenvector $(1, 0)^T$ and the other is $b$ with eigenvector $(0, 1)^T$ since:
\begin{align*}
\begin{pmatrix}
a & 0 \\ 0 & b
\end{pmatrix}
\begin{pmatrix} 1 \\ 0 \end{pmatrix}
& = \begin{pmatrix} a \\ 0 \end{pmatrix}
= a \begin{pmatrix} 1 \\ 0 \end{pmatrix} \\
\begin{pmatrix}
a & 0 \\ 0 & b
\end{pmatrix}
\begin{pmatrix} 0 \\ 1 \end{pmatrix}
& = \begin{pmatrix} 0 \\ b \end{pmatrix}
= b \begin{pmatrix} 0 \\ 1 \end{pmatrix}.
\end{align*}
:::

::: {#exm-projection}
Let $P$ be the 3x3 matrix that represents projection onto a plane $\pi$. What
are the eigenvalues and eigenvectors of $p$?

```{python}


def plot_3d_plane_and_vectors():
    fig = plt.figure()
    ax = fig.add_subplot(111, projection="3d")

    # Define a plane with a point and a normal vector
    point_on_plane = np.array([0, 0, 0])
    normal_vector = np.array([0, 0, 1])  # z = 0 plane

    # Create grid to plot the plane
    x = np.linspace(-2, 2, 10)
    y = np.linspace(-2, 2, 10)
    X, Y = np.meshgrid(x, y)
    Z = (
        -normal_vector[0] * (X - point_on_plane[0])
        - normal_vector[1] * (Y - point_on_plane[1])
    ) / normal_vector[2] + point_on_plane[2]

    ax.plot_surface(
        X,
        Y,
        Z,
        alpha=0.5,
        color="C0",
        rstride=1,
        cstride=1,
        edgecolor="none",
    )

    # Vector in the plane
    in_plane_vector = np.array([1, -1, 0])
    in_plane_vector = (
        in_plane_vector - np.dot(in_plane_vector, normal_vector) * normal_vector
    )
    # Vector orthogonal to the plane (same as normal)
    orthogonal_vector = normal_vector

    # Plot vectors
    def draw_vector(v, color, label):
        ax.quiver(
            0, 0, 0, v[0], v[1], v[2], color=color, label=label, linewidth=2
        )

    draw_vector(in_plane_vector, "C1", "In-plane vector")
    draw_vector(orthogonal_vector, "C2", "Normal vector")

    ax.set_xlim([-2.5, 2.5])
    ax.set_ylim([-2.5, 2.5])
    ax.set_zlim([-0.5, 1])
    ax.axis("off")
    ax.legend()
    ax.set_title("Sample plane and normal vector")

    ax.set_facecolor((0, 0, 0, 0))  # Transparent axis background
    fig.patch.set_alpha(0)  # Transparent figure background

    plt.tight_layout()
    plt.show()


plot_3d_plane_and_vectors()


```

- If $\vec{x}$ is in the plane $\Pi$, then $P \vec{x} = \vec{x}$. This means
  that $\vec{x}$ is an eigenvector and the associated eigenvalue is $1$.

- If $\vec{y}$ is perpendicular to the plane $\Pi$, then $P \vec{y} = \vec{0}$.
  This means that $\vec{y}$ is an eigenvector and the associated eigenvalue is
  $0$.

Let $\vec{y}$ be perpendicular to $\Pi$ (so that $P \vec{y} = \vec{0}$ and
$\vec{y}$ is an eigenvector of $P$), then for any number $s$, we can compute
\begin{equation*}
P (s \vec{y}) = s P \vec{y} = s \vec{0} = \vec{0}.
\end{equation*}
This means that $s \vec{y}$ is also an eigenvector of $P$ associated to the
eigenvalue $0$. As a consequence, when we compute eigenvectors, we need to take
care to *normalise* the vector to ensure we get a unique answer.

We see we end up with a two-dimensional space of eigenvectors (i.e., the plane
$\Pi$) associated to eigenvalue $1$ and a one-dimensional space of eigenvectors
(i.e., the line perpendicular to $\Pi$) eigenvalue $0$. We use the term
*eigenspace* the space of eigenvectors associated to a particular eigenvalue.
:::

::: {#exm-permuatation}
Let $A$ be the permuatation matrix which takes an input two-vector and outputs a
two-vector with the components swapped. The matrix is given by
\begin{equation*}
A = \begin{pmatrix}
0 & 1 \\ 1 & 0 \\
\end{pmatrix}.
\end{equation*}
What are the eigenvectors and eigenvalues of $A$?

- Let $\vec{x} = (1, 1)^T$, then swapping the components of $\vec{x}$ gives back
  the same vector $\vec{x}$. In equations, we can write $A \vec{x} = \vec{x}$.
  This means that $\vec{x}$ is an eigenvector and the eigenvalue is $1$.

- Let $\vec{x} = (-1, 1)^T$, then swapping the components of $\vec{x}$ gives back
  $(1, -1)^T$, which we can see is $-\vec{x}$. In equations, we can write $A
  \vec{x} = -\vec{x}$. This means that $\vec{x}$ is an eigenvector of $A$ and
  the associated eigenvalue is $-1$.

Here we see that again we actually have two one-dimensional eigenspaces.
:::

::: {#exm-rotation}
Recall the rotation matrix $R(\theta)$ given by
$$
R(\theta) = \begin{pmatrix}
\cos \theta & -\sin \theta \\
\sin \theta & \cos \theta
\end{pmatrix}.
$$
> Does the rotation matrix have eigenvalues or eigenvectors?
> Wouldn't it be nice if it did?
:::
:::

### Definitions

::: {#def-evalues}
We say that any vector $\vec{x}$, where $A \vec{x}$ is parallel is $\vec{x}$, is
called an *eigenvector* of $A$. Here by parallel, we mean that there exists a
number $\lambda$ (can be positive, negative or zero) such that
\begin{equation}
\label{eq:evalues}
A \vec{x} = \lambda \vec{x}.
\end{equation}
We call the associated number $\lambda$ an *eigenvalue* of $A$.
:::

### Importance of eigenvalues

Eigenvalues can be used to understand the geometry behind linear transformations
(the action of matrix-vector multiplication).

They can also be used to find a *useful* basis (of eigenvectors) when working
with large datasets.

The idea of using eigenvectors to form a basis is a key step in the PageRank
algorithm which Google used to revolutionise search algorithms.

## Characteristic equation

The eigenvalues of a matrix $A$ satisfy the **characteristic equation** given by
\begin{equation}
\label{eq:char}
\det( A - \lambda I_n ) = 0.
\end{equation}

::: {.notes}
To compute eigenvalues and eigenvectors, we start from \eqref{eq:evalues} and
move everything to the left-hand side and use the identity matrix $(I_n)$:
\begin{equation*}
(A - \lambda I_n) \vec{x} = \vec{0}.
\end{equation*}
This tells us that if we want to find an eigenvalue of $A$, then we need to find
a number $\lambda$ such that $(A - \lambda I_n)$ can multiply a non-zero vector
and give us back the zero-vector. This happens when $(A - \lambda I)$ is
*singular* (@thm-det).

As we saw earlier one way to test if a matrix is singular, is if the determinant
is 0. This gives us a test we can use to determine eigenvalues:
\begin{equation}
\label{eq:char}
\det( A - \lambda I_n ) = 0.
\end{equation}
In fact, this equation no longer depends on the eigenvector $\vec{x}$, and if we
can find solutions $\lambda$ to this equation then $\lambda$ is an eigenvalue of
$A$.

We call \eqref{eq:char} the *characteristic equation* or *eigenvalue equation*.
We will see that \eqref{eq:char} gives us a degree $n$ polynomial equation in
$\lambda$.

Once we have found an eigenvalue by solving the characteristic equation for a
value $\lambda^*$, we need to find a vector $\vec{x}$ such that
\begin{equation*}
(A - \lambda^*) \vec{x} = \vec{0}.
\end{equation*}
In general, this is possible using a variation of Gaussian elimination with
pivoting, but we do not explore this method in this module.
:::

### Example 1

Find the eigenvalues and eigenvectors of the matrix
\begin{equation*}
A = \begin{pmatrix}
3 & 1 \\ 1 & 3 \\
\end{pmatrix}.
\end{equation*}

::: {.notes}
Then, we can compute that
\begin{align*}
\det(A - \lambda I_n)
& = \det \begin{pmatrix}
3 - \lambda & 1 \\ 1 & 3 - \lambda
\end{pmatrix} \\
& = (3 - \lambda)(3 - \lambda) - 1 \times 1 \\
& = \lambda^2 + 6 \lambda + 8.
\end{align*}
So we want to find values $\lambda$ such that
\begin{equation*}
\det(A - \lambda I_n) =\lambda^2 + 6 \lambda + 8 = 0.
\end{equation*}
We can read off, by factorisation, that the values of $\lambda$ are $4$ and $2$.

We can now start computing the associated eigenvectors.

To find the eigenvector associated with the eigenvalue $4$. We see that
\begin{equation*}
A - 4 I_n = \begin{pmatrix} -1 & 1 \\ 1 & -1 \end{pmatrix}.
\end{equation*}
We can identify that $(A - 4I_n) (1, 1)^T = \vec{0}$.
So $(1, 1)$ is an eigenvector associated with $4$.

To find the eigenvector associated with the eigenvalue $2$. We see that
\begin{equation*}
A - 2I_n = \begin{pmatrix} 1 & 1 \\ 1 & 1 \end{pmatrix}.
\end{equation*}
We can identify that $(A - 2 I_n) (-1, 1)^T = \vec{0}$.
So $(-1, 1)$ is an eigenvector associated with $2$.
:

We note that this example is actually surprisingly similar to @exm-permuatation.
We see that the eigenvectors are actually the same! We can see that the matrices
are related too:
\begin{equation*}
\begin{pmatrix}
0 & 1 \\ 1 & 0 \\
\end{pmatrix}
-3 I
= \begin{pmatrix}
3 & 1 \\ 1 & 3
\end{pmatrix}.
\end{equation*}
So we can compute that if $A \vec{x} = \lambda \vec{x}$ then
\begin{equation*}
(A + 3 I) \vec{x} = \lambda \vec{x} + 3 \vec{x} = (\lambda + 3) \vec{x}.
\end{equation*}
So we see that $\vec{x}$ is also an eigenvector of $A$ and the associated
eigenvector is $\lambda + 3$.
:::

### Example 2

Let $B$ be the $2 \times 2$ matrix given by
\begin{equation*}
B = \begin{pmatrix}
3 & 1 \\ 0 & 3
\end{pmatrix}.
\end{equation*}
Find the eigenvalues and eigenvectors of $B$.

::: {.notes}
If we follow our procedure above we get a single repeated eigenvalue $3$.

Looking at the shifted matrix, $A - 3 I_n$:
\begin{equation*}
A - 3 I_n = \begin{pmatrix}
0 & 1 \\ 0 & 0
\end{pmatrix}.
\end{equation*}
we can identify one eigenvector $(1, 0)^T$, but there is no other eigenvector
(in a different direction)! Indeed, we can compute that:
\begin{align*}
(A - 3 I_n) \begin{pmatrix}
x \\ y
\end{pmatrix}
= \begin{pmatrix}
0 & 1 \\ 0 & 0 \\
\end{pmatrix}
 \begin{pmatrix}
x \\ y
\end{pmatrix}
= \begin{pmatrix}
y \\ 0
\end{pmatrix}.
\end{align*}
This tells us that if $(A - 3 I_n) (x, y)^T = \vec{0}$ if, and only if, $y = 0$.
Thus all eigenvectors have the form $(x, 0)^T$ and point in the same direction
as $(1, 0)^T$.
:::

### Exercise

Find the eigenvalues and eigenvectors of the matrix
$$
\begin{pmatrix} 9 & -2 \\ -2 & 6 \end{pmatrix}.
$$

### Example 3

Let $Q$ denote the $2 \times 2$ matrix that rotates any vector by $\pi/2$
($=90^\circ$):
\begin{equation*}
Q = \begin{pmatrix}
0 & -1 \\ 1 & 0
\end{pmatrix}.
\end{equation*}
Find the eigenvalues and eigenvectors of $Q$.

::: {.notes}
Our intuition says that there can be no vectors that when rotated by $\pi/2$
give something parallel to the input vector, but we can still compute:
\begin{equation*}
\det Q = \det \begin{pmatrix}
-\lambda & -1 \\ 1 & -\lambda
\end{pmatrix}
= \lambda^2 + 1.
\end{equation*}
So we can find eigenvalues by finding the values $\lambda$ such that
\begin{equation*}
\lambda^2 + 1 = 0.
\end{equation*}
:::

# Complex numbers {#sec-complex-numbers}

## Basic definitions

Consider the polynomial equation
\begin{equation}
\lambda^2 + 1 = 0.
\end{equation}

```{python}
# | fig-cap: Plot of $\lambda^2 + 1$.
# | echo: false

x = np.linspace(-1, 1)
y = x**2 + 1

plt.plot(x, y)
plt.axhline(y=0.0, c="k")
plt.xlabel("$\\lambda$")
plt.ylabel("$\\lambda^2 + 1$")
plt.grid(True)
plt.show()
```

::: {.notes}
We can see that this equation has no solution over the real numbers: There are
no real values $x$ such that $x^2 + 1 = 0$.
:::

### Definitions

The key idea of complex numbers is to create a new symbol, which we will call
$i$, or the **imaginary unit** which satisfies:
\begin{equation*}
 i^2 = -1 \qquad \sqrt{-1} = i.
\end{equation*}
By taking multiples of this imaginary unit, we can create many more new numbers,
like $3i, \sqrt{5} i$ or $-12 i$. These are examples of **imaginary numbers**.

### Definitions ii

We form **complex numbers** by adding real and imaginary numbers whilst keeping
each part separate -- for example, $2 + 3i$, $\frac{1}{2} + \sqrt{5} i$ or $12 -
12i$.

::: {#def-complex}
Any number that can be written as $z = a + bi$ with $a, b$ real numbers and $i$
the imaginary unit is called  *complex number*. In this format, we call $a$ the
**real part** of $z$ and $b$ the **imaginary part** of $z$.
:::

We notice that all real numbers $x$ must also be complex numbers since $x = x +
0 i$.

### History

Among the first recorded uses of complex numbers in European mathematics was by
an Italian mathematician, Gerolamo Cardano, in around 1545. He later described
complex numbers as being "as subtle as they are useless" and "mental torment".

The term imaginary was coined by René Descartes in 1637:

> ... sometimes only imaginary, that is one can imagine as many as I said in
> each equation, but sometimes there exist no quantity that matches that which
> we imagine.

### Exercise

What are the real and imaginary parts of these numbers?

1. $3 + 6i$
2. $-3.5 + 2i$
3. $5$
4. $7i$

## Calculations with complex numbers

Addition and subtraction are relatively straightforward: we treat the real and
imaginary parts separately.

Compute
\begin{align*}
(2 + 3i) + (12 - 12i) &= \\
(2 + 3i) - (12 - 12i) &= \\
6 (2 + 3i) &= \\
\frac{12 - 12i}{6} & = \phantom{XX}.
\end{align*}

### Exercises

Compute $(3+6i) + (-3.5 + 2i)$ and $(3 + 6i) - (-3.5 + 2i)$.

### Multiplication of complex numbers

For multiplication between complex numbers, things are harder. We expand
brackets and apply the rule that $i^2 = -1$:

**Example.**
Compute $(2 + 3i) \times (12 - 12i)$.

::: {.notes}
\begin{align*}
& (2 + 3i) \times (12 - 12i)  \\
& = 2 \times 12 + 3i \times 12 + 2 \times - 12 i + 3i \times - 12 i
&& \text{(expand brackets)} \\
& = 2 \times 12 + (12 \times 3) i + (2 \times - 12) i + (3 \times - 12) \times
i^2 && \text{(rearrange)} \\
& = 24 + 36 i - 24 i - 36 \times i^2 && \text{(compute products)} \\
& = 24 + 36 i - 24 i + 36 && \text{(use $i^2 = -1$)} \\
& = 60 + 12 i && \text{(collect terms)}.
\end{align*}
:::

### Multiplication of complex numbers

This leads us to a general formula:
\begin{equation*}
(a + bi) \times (c + di) = (ac - bd) + (ad + bc) i.
\end{equation*}

::: {#exr-mult}
Compute $(3 + 6i) \times (-3.5 + 2i)$.
:::

### Remark

One thing to be careful of when considering products is that the identity $i^2
= -1$ appears to break one rule of arithmetic of square roots:
\begin{equation*}
i^2 = (\sqrt{-1})^2 = \sqrt{-1} \sqrt{-1} \neq \sqrt{(-1) \times (-1)} = \sqrt{1}
= 1.
\end{equation*}
In fact, we have that $\sqrt{x} \sqrt{y} = \sqrt{xy}$ only if $x, y > 0$.

## A geometric picture

The idea of adding complex numbers by considering real and imaginary parts
separately is reminiscent of adding two-dimensional vectors. For this reason, it
is often helpful to think of complex numbers as points in *the complex plane*.

### Complex plane

The complex plane is the two-dimensional space formed by considering the real
and imaginary parts of a complex number as two different coordinate axes.

::: {#exm-plane}

```{python}
# | echo: false
# | caption: Examples of complex numbers as points in the complex plane.

zz = {
    "3 + 6i": complex(3, 6),
    "-3.5 + 2i": complex(-3.5, 2),
    "5": complex(5, 0),
    "7i": complex(0, 7),
}

for txt, z in zz.items():
    line = plt.plot(np.real(z), np.imag(z), "o")
    plt.text(
        np.real(z) + 0.1, np.imag(z) + 0.05, txt, color=line[0].get_color()
    )

plt.xlabel("Real part")
plt.ylabel("Imaginary part")
plt.grid()
plt.show()
```

:::

::: {.notes}
Adding complex numbers looks just like adding two dimensional vectors! We can
also use this geometric picture to help with some further operations.
:::

### Complex conjugate

The *complex conjugate* of a complex number $z = a + bi$ is given by $\bar{z} =
a - bi$. The complex conjugate is that number we used before when working out
how to divide complex numbers.

::: {#exm-conjugate}
Find the complex conjugate of (i) $2 + 3i$ and (ii) $12 - 12i$
:::

::: {#exr-conjugate}
Find the complex conjugates of (i) $3 + 6i$ and (ii) $-3.5 + 2i$.
:::

::: {.notes}
We have already seen that the complex conjugate of a complex number is helpful
when performing division of complex numbers. The reason is that computing the
product of a number and its conjugate always gives a real, positive number:
\begin{align*}
& (a + bi) \times (a - bi) \\
& = (a \times a) + (a \times - b i) + (b i \times a) + (bi \times - bi) \\
& = (a \times a) + (a \times -b) i + (b \times a) i + (b \times - b) i^2 \\
& = (a \times a) + (a \times -b + b \times a) i - (b \times - b) \\
& = a^2 + b^2 + 0 i.
\end{align*}
:::

### Modulus

The **modulus** (sometimes called the **absolute value**) of a complex number
$z = a + bi$
\begin{equation}
\label{eq:modulus}
|z| = |a + bi| = \sqrt{a^2 + b^2} = \sqrt{z \bar{z}}.
\end{equation}

### Example modulus

```{python}
# | echo: false
# | caption: "Examples of moduli of complex numbers as points in the complex
# |           plane."

zz = {
    "3 + 6i": complex(3, 6),
    "-3.5 + 2i": complex(-3.5, 2),
    "5+0i": complex(5, 0),
    "0+7i": complex(0, 7),
}

# Set up the plot
fig, ax = plt.subplots()
ax.axhline(0, color="black", linewidth=0.5)
ax.axvline(0, color="black", linewidth=0.5)

for key, z in zz.items():
    a, b = z.real, z.imag
    mod = abs(z)
    arg = np.arctan2(b, a)

    line = plt.plot(a, b, "o")
    color = line[0].get_color()
    ax.arrow(
        0,
        0,
        a,
        b,
        head_width=0.2,
        head_length=0.3,
        linewidth=2,
        color=color,
        ec=color,
        length_includes_head=True,
    )

    # Create the modulus label
    key = key.replace(" ", "")
    match = re.fullmatch(r"([+-]?\d*\.?\d+)\+([-]?\d*\.?\d+)i", key)
    re_txt, im_txt = match.group(1), match.group(2)

    txt = ""
    if re_txt != "0":
        txt += re_txt
    if im_txt != "0":
        txt += f"{im_txt}i"
    plt.text(np.real(z) + 0.1, np.imag(z) + 0.05, f"${txt}$", color=color)

    label = f"$|{txt}| = \\sqrt{{{a**2 + b**2}}}$"
    ax.text(
        a / 2 - b / (4 * mod),
        b / 2 + a / (4 * mod),
        label,
        ha="center",
        va="center",
        rotation=np.degrees(arg),
        fontsize=9,
        color=color,
    )

# Formatting
ax.set_xlabel("Real")
ax.set_ylabel("Imaginary")
ax.set_title("Complex Numbers in the Complex Plane")
ax.grid(True)
ax.set_aspect("equal", adjustable="box")

plt.show()
```

### Exercise

Find the value of
\begin{equation}
|3 + 6i| \quad \text{and} \quad |-3.5 + 2i|.
\end{equation}

### Rules for modulus of complex numbers

- If $z$ and $y$ are complex numbers, then $|zy| = |z| |y|$.

::: {.incremental}
- In particular if $|y| = 1$, then $|zy| = |z|$.

- So we can think of multiplying by a complex number with modulus 1, as a rotation!
:::

::: {.notes}
Consider two complex numbers $z = a + bi$ and $y = c + di$. Then, we have
already seen that
\begin{align*}
z y
& = (a + bi) \times (c + di) = (ac - bd) + (ad + bc)i.
\end{align*}
We can compute the square of the modulus of the product $zy$ as
\begin{align*}
|zy|^2
& = (ac - bd)^2 + (ad + bc)^2 \\
& = a^2 c^2 - 2 abcd + b^2 d^2 + a^2 d^2 + 2 abcd + b^2 c^2 \\
& = a^2 c^2 + b^2 d^2 + a^2 d^2 + b^2 c^2 \\
& = (a^2 + b^2) (c^2 + d^2),
\end{align*}
and we have computed that $|zy|= |z| |y|$.

In particular, if $y$ has modulus 1, then $|zy| = |z|$. This means that $zy$ and
$z$ are the same distance from the origin but 'point' in different directions.
We can write the real and imaginary parts as $y = c + di = \cos(\theta) + i
\sin(\theta)$, where $\theta$ is the angle between the positive real axis and
the line between $0$ and $y$. Then
\begin{align*}
z y
& = (ac - bd) + (ad + bc)i \\
& = (a \cos(\theta) - b \sin(\theta)) + (a \sin(\theta) + b\cos(\theta)) i.
\end{align*}
Recalling the example of a rotation matrix from @exm-special-matrices, we see
that multiplying by $y$ is the same as rotating the complex point ($z$) by an
angle of $\theta$ radians in the anti-clockwise direction.
:::

### Polar representation

::: {.notes}
This leads us to thinking *polar coordinates* for the complex plane. Polar
coordinates are a different form of coordinates that replace the usual $x$ and
$y$-directions (up and across) by two values which represent the distance to the
origin (that we call radius) and angle counted in the anti-clockwise direction
to the positive $x$-axis (that we call the angle).
:::

When talking about a complex number $z$ represented in the complex plane, we
know that the modulus $|z|$ represents the radius. We can form an angle $\theta$
to represent the angle of a complex number that we know call the **argument**.

It can be found by computing arctan2 (a quadrant aware version of arctan) of the
real and imaginary parts of $z$.

```{python}
# |echo: true
print("angle of 1 + 0i:", np.arctan2(1, 0))
print("angle of 0 + 1i:", np.arctan2(0, 1))
```

### Picture

```{python}
# | echo: false
# | caption: "Examples of arguments of complex numbers as points in the complex
# |            plane."

zz = {
    "3 + 6i": complex(3, 6),
    "-3.5 + 2i": complex(-3.5, 2),
    "5": complex(5, 0),
    "7i": complex(0, 7),
}

# Set up the plot
fig, ax = plt.subplots()
ax.axhline(0, color="black", linewidth=0.5)
ax.axvline(0, color="black", linewidth=0.5)

spacing = 0.8
plot_radius = spacing

for key, z in zz.items():
    a, b = z.real, z.imag
    mod = abs(z)
    arg = np.angle(z)
    arg_deg = np.degrees(arg)

    line = plt.plot(a, b, "o")
    color = line[0].get_color()
    ax.plot([0, a], [0, b], "--", color=color)

    t = np.linspace(0, arg)
    plt.plot(plot_radius * np.cos(t), plot_radius * np.sin(t), color=color)

    ax.text(
        (plot_radius + 0.15) * np.cos(0.8 * arg),
        (plot_radius + 0.15) * np.sin(0.8 * arg),
        f"$\\arg({key})$",
        ha="center",
        va="center",
        rotation=np.degrees(0.8 * arg - np.pi / 2),
        fontsize=9,
        color=color,
    )
    plot_radius = plot_radius + spacing

# Formatting
ax.set_xlabel("Real")
ax.set_ylabel("Imaginary")
ax.set_title("Complex Numbers in the Complex Plane")
ax.grid(True)
ax.set_aspect("equal", adjustable="box")

plt.show()
```


### Polar form

Let $z$ be a complex number. The **polar form** of $z$ is $R (\cos \theta + i
\sin \theta)$. We call $R$ the modulus of $z$ and $\theta$ is the argument of
$z$.

The representation of the angle unique up to adding integer multiples of $2
\pi$, since rotating a point by $2 \pi$ about the origin leaves it unchanged.

### Example

Find the polar form of $z = 12 - 12i$.

::: {.notes}
Let $z = 12 -12i$. Then
\begin{align*}
|z| = |12 - 12i| = \sqrt{12^2 + 12^2} = \sqrt{2 \times 144} = 12 \sqrt{2}.
\end{align*}
We have $\arg{z} = -\pi / 4$ since
\begin{equation*}
\cos(-\pi/4) = \frac{1}{\sqrt{2}}, \quad \text{and} \quad \sin(-\pi/4)
= \frac{-1}{\sqrt{2}},
\end{equation*}
so

\begin{equation*}
12 \sqrt{2} (\cos(-\pi/4) + i \sin(-\pi/4))
= 12 \sqrt{2} \left( \frac{1}{\sqrt{2}} + i \frac{-1}{\sqrt{2}} \right)
= 12 - 12i.
\end{equation*}
:::

### Exercise
Compute the modulus and argument of $2$, $3i$ and $4 + 4i$.

### Geometric view of complex multiplication

The polar representation of complex numbers then gives us a nice way to
understand multiplication of complex numbers.

If $y \neq 0$, then we can check that $\left| \frac{y}{|y|} \right| = 1$ and
$\arg{y} = \arg{\frac{y}{|y|}}$.

Then writing $zy = z \frac{y}{|y|} |y|$, we can use our calculations above to
infer that multiplying by $y$ corresponds to an anticlockwise rotation by
$\arg{y}$ then scaling by $|y|$.

## Euler's formula

Euler's formula is relates the polar form of a complex number to complex
exponentials: Let $x$ be a real number, then
$$
\exp (i x) = \cos x + i \sin x.
$$

### Euler's identity

Euler's formula is the key important step for showing Euler's identity:
$$
\exp(i \pi) = -1.
$$
This is shown by applying Euler's formula at $x= \pi$. This is a formula which
many mathematicians a surprising and beautiful result!


## Solving polynomial equations

::: {#thm-fund-alg}

### The Fundamental Theorem of Algebra

For any complex numbers $a_0, \ldots, a_n$ not all zero, there is at least one
complex number $z$ which satisfies:
\begin{equation*}
a_n z^n + \cdots + a_1 z + a_0 = 0
\end{equation*}
:::

::: {.notes}
This is not true over the real numbers!
:::

### Revisiting the rotation example

Consider the polynomial equation
\begin{equation}
x^2 + 1 = 0.
\end{equation}

::: {.notes}
We saw before that this equation has no solution over the real numbers, but the
Fundamental Theorem of Algebra tells us there must be at least one solution
which is a complex number. In fact it has two solutions - $i$ and $-i$:
\begin{align*}
 & i^2 + 1 = 0 \\
 & (-i)^2 + 1 = (-1)^2 i^2 + 1 = i^2 + 1 = 0.
\end{align*}
:::

### Plot of $z^2 + 1$

```{python}
# | echo: false


# Define the complex function f(z) = z^2 + 1
def f(z):
    return z**2 + 1


# Create a grid of complex numbers over a region of the complex plane
x = np.linspace(-2, 2, 400)
y = np.linspace(-2, 2, 400)
X, Y = np.meshgrid(x, y)
Z = X + 1j * Y

# Compute the modulus of f(z) to plot contours
F = np.abs(f(Z))

# Create custom normalization: red at 0, yellow at 1, green at 10
norm = mcolors.TwoSlopeNorm(vmin=0, vcenter=1, vmax=10)


# Create the contour plot
fig, ax = plt.subplots()
ax.plot(0, 1, "ro")
ax.plot(0, -1, "ro")
contourf = ax.pcolormesh(X, Y, F, cmap="RdYlGn", alpha=0.5, norm=norm)
contour = ax.contour(X, Y, F, levels=30, cmap="RdYlGn", norm=norm)
ax.axhline(0, color="black", linewidth=0.5)
ax.axvline(0, color="black", linewidth=0.5)
ax.set_title("Contour Plot of $|z^2 + 1|$ Over the Complex Plane")
ax.set_xlabel("Real part")
ax.set_ylabel("Imaginary part")
fig.colorbar(contourf, ax=ax, label="$|z^2 + 1|$", ticks=[0, 0.5, 1, 5, 10])

plt.tight_layout()
plt.show()
```

::: {.notes}
Notice that along the real line (Imaginary part $=0$), the value of the function
is always above 1.
:::

### Quadratic formula

In general, to find complex roots of other quadratic equations, we can apply the
quadratic formula:

::: {#exm-polynomial1}
Find the values of $z$ which satisfy $z^2 - 2z + 2 = 0$
:::

::: {.notes}
\begin{align*}
z = \frac{+2 \pm \sqrt{(-2)^2 - 4 \times 1 \times 2}}{2} =
\frac{2 \pm \sqrt{-4}}{2} = \frac{2 \pm 2 \sqrt{-1}}{2} = 1 \pm i.
\end{align*}

We will see in later sections that although this is one possible solution to
compute the eigenvalues for $2 \times 2$ matrices this approach becomes
infeasible for larger size matrices and we need another approach!
:::

### Existence of eigenvalues

::: {#thm-existence}
Any square $n \times n$ matrix has $n$ complex eigenvalues (possibly not
distinct).
:::

::: {.proof}
For any matrix the characteristic equation \eqref{eq:char} is a degree $n$
polynomial. The Fundamental Theorem of Algebra (@thm-fund-alg) tells us that any
degree $n$ polynomial has $n$ roots over the complex numbers. The $n$ roots of
the characteristic equation are the $n$ eigenvalues.
:::

:: {.notes}
The Abel-Ruffini theorem states that there is no solution in the radicals for a
general polynomial of degree 5 or higher with arbitrary coefficients. This
implies that there is no 'nice' closed form for roots of polynomials of degree 5
or higher. So, if we want an algorithm to find eigenvalues and eigenvectors of
larger matrices then we need to do something else!
:::

# Summary

- We have given a formula for computing eigenvalues of matrices and a definition
  of eigenvectors.

- We have introduced complex numbers so that we can solve the characteristic
  equation.

- The power of the characteristic equation is limited since we have no general
  formula for solving higher order polynomials.
